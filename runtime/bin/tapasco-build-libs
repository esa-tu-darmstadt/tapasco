#!/usr/bin/python3
#
# Copyright (c) 2014-2020 Embedded Systems and Applications, TU Darmstadt.
#
# This file is part of TaPaSCo
# (see https://github.com/esa-tu-darmstadt/tapasco).
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.
#

import argparse
import sys
import subprocess
from socket import gethostname
import os
import signal
from os import path

default_cmd = 'mkdir -p {0} && cd {0} && cmake {1} {2} && make -j $(nproc) install DESTDIR={0}/install'
tlkm_cmd = 'mkdir -p {0} && cd {0} && cp -a {1} ./tlkm && cd ./tlkm && make -j $(nproc) {2} {3} {4}'

parser = argparse.ArgumentParser()
parser.add_argument(
    '--mode',
    help='build mode (default: %(default)s)',
    default='release',
    choices=[
        'clean',
        'release',
        'debug',
         'driver_debug'])
parser.add_argument(
    '--rebuild',
    help='force rebuild libs (default: %(default)s)',
    action='store_true')
parser.add_argument(
    '--rebuild_simlibs',
    help='force recompilation of questa simulation libraries (default: %(default)s)',
    action='store_true')
parser.add_argument(
    '--shared',
    help='build shared library instead of static',
    action='store_true')
parser.add_argument(
    '--package',
    help='build installation packages',
    action='store_true')
parser.add_argument(
    '--skip_driver',
    help='do not build the driver',
    action='store_true')
parser.add_argument(
    '--skip_runtime',
    help='do not build the tapasco runtime',
    action='store_true')
parser.add_argument(
    '--target',
    help='cross compile for other target (clang, zynq)',
    default='',
    choices=[
        '',
        'clang',
         'zynq'])
parser.add_argument(
    '--enable_svm',
    help='enable driver support for Shared Virtual Memory (SVM)',
    action='store_true')
parser.add_argument(
    '--enable_sim',
    help='enable simulation support in the driver and setup the tapasco simulation',
    action='store_true')
args = parser.parse_args()

clean = args.mode == 'clean'
debug = args.mode == 'debug' or args.mode == 'driver_debug'
driver_debug = args.mode == 'driver_debug'
debug_flags = '-DCMAKE_BUILD_TYPE=Debug' if debug else '-DCMAKE_BUILD_TYPE=Release'
build_folder = 'build' if args.target == '' else 'build-' + args.target

crosscompile_flags = ''
if args.target == 'zynq':
    print('Build target: ' + args.target)
    crosscompile_flags = '-DCMAKE_TOOLCHAIN_FILE=%s/cmake/zynq_cross_toolchain.cmake' % os.environ[
        'TAPASCO_HOME_RUNTIME']
if args.target == 'clang':
    print('Build target: ' + args.target)
    crosscompile_flags = '-DCMAKE_TOOLCHAIN_FILE=%s/cmake/clang_toolchain.cmake' % os.environ[
        'TAPASCO_HOME_RUNTIME']

shared_flags = '-DBUILD_SHARED_LIBS:BOOL={}'.format(
    'ON' if args.shared else 'OFF')

print('Build mode: {}'.format(args.mode))

mdir = '{}/kernel'.format(os.environ['TAPASCO_HOME_RUNTIME'])
bdir = '{}/{}'.format(os.environ['TAPASCO_WORK_DIR'], build_folder)
sdir = '{}/simulation'.format(os.environ['TAPASCO_WORK_DIR'])

if clean or args.rebuild:
    subprocess.call(['rm -rf %s' % bdir], shell=True)
    subprocess.call(['cd %s && make clean' % mdir], shell=True)
    subprocess.call([f'make -C {sdir} clean'], shell=True)

if not clean:
    if debug:
        print('Building debug mode libraries...')
    else:
        print('Building release mode libraries...')

    if 'LINUX_HOME' in os.environ:
        subprocess.call(['make -C ' +
                         os.environ['LINUX_HOME'] +
                         ' scripts'], shell=True)

    if not args.skip_driver:
        ret = subprocess.call(
            [tlkm_cmd.format(bdir, mdir, '' if driver_debug else 'release', 'EN_SVM=1' if args.enable_svm else '', 'ENABLE_SIM=1' if args.enable_sim else '')], shell=True)
        if ret:
            print('Driver build failed!')
            sys.exit(ret)
    if not args.skip_runtime:
        cmd = default_cmd.format(bdir,
                                 " ".join([crosscompile_flags,
                                           debug_flags,
                                           shared_flags]),
                                 os.environ['TAPASCO_HOME_RUNTIME'])
        ret = subprocess.call([cmd], shell=True)
        if ret:
            print('Tapasco build failed!')
            sys.exit(ret)

    if args.enable_sim and not path.exists(f"{sdir}/.setup_lock"):
        compile_simlibs = None

        def interrupt_handler(sig, frame):
            global compile_simlibs
            subprocess.call([f"rm {sdir}/.setup_lock"], shell=True)
            if compile_simlibs is not None and compile_simlibs.returncode is None:
                grp = os.getpgid(compile_simlibs.pid)
                os.killpg(grp, signal.SIGTERM)

            print('')
            sys.exit(0)

        subprocess.call([f"cp -r {os.environ['TAPASCO_HOME_RUNTIME']}/simulation {os.environ['TAPASCO_WORK_DIR']}"], shell=True)
        subprocess.call([f"touch {sdir}/.setup_lock"], shell=True)

        build_simlibs = not path.exists(f'{sdir}/compile_simlib') or args.rebuild_simlibs
        if build_simlibs:
            # store previous signal handler
            original_sigint_handler = signal.getsignal(signal.SIGINT)
            signal.signal(signal.SIGINT, interrupt_handler)
            compile_simlibs = subprocess.Popen(['make', 'simlib_questa'],
                                               stdin=subprocess.DEVNULL,
                                               stdout=subprocess.PIPE,
                                               cwd=sdir)
        else:
            print('\033[93m' + 'Folder with simulation libraries already exists, assuming Libraries are already built. To force a build use --rebuild_simlibs' + '\033[0m')

        # installing python dependencies
        ret_config = subprocess.call([f'make configure'], cwd=sdir, shell=True)
        # generating protocol buffer definitions and patching relative imports
        ret_protos = subprocess.call([f'make protos'], cwd=sdir, shell=True)

        ret_simlibs = False

        if build_simlibs:
            for line in compile_simlibs.stdout:
                print(line.decode('utf-8'), end='')
            ret_simlibs = compile_simlibs.wait()
            signal.signal(signal.SIGINT, original_sigint_handler)

        if ret_config or ret_protos or ret_simlibs:
            print('Simulation setup failed')

        subprocess.call([f"rm {sdir}/.setup_lock"], shell=True)
        print('Simulation setup done')

    elif args.enable_sim and path.exists(f"{sdir}/.setup_lock"):
        print('\033[93m' + f'Lock file {sdir}/.setup_lock exists. Another setup might be ongoing. If not, remove the file and try again.' + '\033[0m')

    if args.package:
        ret = subprocess.call(
            "cd {0} && make -j package".format(bdir),
            shell=True)
        if ret:
            print('Tapasco packaging failed!')
            sys.exit(ret)

