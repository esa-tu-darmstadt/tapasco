//
// Generated by Bluespec Compiler, version 2022.01 (build 066c7a8)
//
// On Sat Apr  9 17:38:37 UTC 2022
//
//
// Ports:
// Name                         I/O  size props
// drp_addr                       O    11 const
// drp_en                         O     1 reg
// drp_do                         O    16 const
// drp_we                         O     1 reg
// msix_vectors_per_pf0           O    32 const
// msix_vectors_per_pf1           O    32 const
// msix_vectors_per_pf2           O    32 const
// msix_vectors_per_pf3           O    32 const
// msix_vectors_per_vfg0          O    32 const
// msix_vectors_per_vfg1          O    32 const
// msix_vectors_per_vfg2          O    32 const
// msix_vectors_per_vfg3          O    32 const
// numvec_valid                   O     1 reg
// clk                            I     1 clock
// resetn                         I     1 reset
// drp_rdy                        I     1 reg
// drp_di                         I    16 unused
// numvec_done                    I     1 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkQDMAConfigurator(clk,
			  resetn,

			  drp_addr,

			  drp_en,

			  drp_do,

			  drp_we,

			  drp_rdy,

			  drp_di,

			  msix_vectors_per_pf0,

			  msix_vectors_per_pf1,

			  msix_vectors_per_pf2,

			  msix_vectors_per_pf3,

			  msix_vectors_per_vfg0,

			  msix_vectors_per_vfg1,

			  msix_vectors_per_vfg2,

			  msix_vectors_per_vfg3,

			  numvec_valid,

			  numvec_done);
  input  clk;
  input  resetn;

  // value method drp_drp_addr
  output [10 : 0] drp_addr;

  // value method drp_drp_en
  output drp_en;

  // value method drp_drp_do
  output [15 : 0] drp_do;

  // value method drp_drp_we
  output drp_we;

  // action method drp_get_rdy
  input  drp_rdy;

  // action method drp_get_di
  input  [15 : 0] drp_di;

  // value method msix_vec_ctrl_msix_vectors_per_pf0
  output [31 : 0] msix_vectors_per_pf0;

  // value method msix_vec_ctrl_msix_vectors_per_pf1
  output [31 : 0] msix_vectors_per_pf1;

  // value method msix_vec_ctrl_msix_vectors_per_pf2
  output [31 : 0] msix_vectors_per_pf2;

  // value method msix_vec_ctrl_msix_vectors_per_pf3
  output [31 : 0] msix_vectors_per_pf3;

  // value method msix_vec_ctrl_msix_vectors_per_vfg0
  output [31 : 0] msix_vectors_per_vfg0;

  // value method msix_vec_ctrl_msix_vectors_per_vfg1
  output [31 : 0] msix_vectors_per_vfg1;

  // value method msix_vec_ctrl_msix_vectors_per_vfg2
  output [31 : 0] msix_vectors_per_vfg2;

  // value method msix_vec_ctrl_msix_vectors_per_vfg3
  output [31 : 0] msix_vectors_per_vfg3;

  // value method msix_vec_ctrl_numvec_valid
  output numvec_valid;

  // action method msix_vec_ctrl_acceptDone
  input  numvec_done;

  // signals for module outputs
  wire [31 : 0] msix_vectors_per_pf0,
		msix_vectors_per_pf1,
		msix_vectors_per_pf2,
		msix_vectors_per_pf3,
		msix_vectors_per_vfg0,
		msix_vectors_per_vfg1,
		msix_vectors_per_vfg2,
		msix_vectors_per_vfg3;
  wire [15 : 0] drp_do;
  wire [10 : 0] drp_addr;
  wire drp_en, drp_we, numvec_valid;

  // register drpEn
  reg drpEn;
  wire drpEn$D_IN, drpEn$EN;

  // register drpRdy
  reg drpRdy;
  wire drpRdy$D_IN, drpRdy$EN;

  // register drpWE
  reg drpWE;
  wire drpWE$D_IN, drpWE$EN;

  // register numvecDone
  reg numvecDone;
  wire numvecDone$D_IN, numvecDone$EN;

  // register numvecValid
  reg numvecValid;
  wire numvecValid$D_IN, numvecValid$EN;

  // register state
  reg [2 : 0] state;
  reg [2 : 0] state$D_IN;
  wire state$EN;

  // rule scheduling signals
  wire WILL_FIRE_RL_finishDrpWrite, WILL_FIRE_RL_startDrp;

  // value method drp_drp_addr
  assign drp_addr = 11'd213 ;

  // value method drp_drp_en
  assign drp_en = drpEn ;

  // value method drp_drp_do
  assign drp_do = 16'd255 ;

  // value method drp_drp_we
  assign drp_we = drpWE ;

  // value method msix_vec_ctrl_msix_vectors_per_pf0
  assign msix_vectors_per_pf0 = 32'd256 ;

  // value method msix_vec_ctrl_msix_vectors_per_pf1
  assign msix_vectors_per_pf1 = 32'd0 ;

  // value method msix_vec_ctrl_msix_vectors_per_pf2
  assign msix_vectors_per_pf2 = 32'd0 ;

  // value method msix_vec_ctrl_msix_vectors_per_pf3
  assign msix_vectors_per_pf3 = 32'd0 ;

  // value method msix_vec_ctrl_msix_vectors_per_vfg0
  assign msix_vectors_per_vfg0 = 32'd0 ;

  // value method msix_vec_ctrl_msix_vectors_per_vfg1
  assign msix_vectors_per_vfg1 = 32'd0 ;

  // value method msix_vec_ctrl_msix_vectors_per_vfg2
  assign msix_vectors_per_vfg2 = 32'd0 ;

  // value method msix_vec_ctrl_msix_vectors_per_vfg3
  assign msix_vectors_per_vfg3 = 32'd0 ;

  // value method msix_vec_ctrl_numvec_valid
  assign numvec_valid = numvecValid ;

  // rule RL_startDrp
  assign WILL_FIRE_RL_startDrp = state == 3'd3 && numvecDone ;

  // rule RL_finishDrpWrite
  assign WILL_FIRE_RL_finishDrpWrite = state == 3'd2 && drpRdy ;

  // register drpEn
  assign drpEn$D_IN = state != 3'd1 ;
  assign drpEn$EN = state == 3'd1 || WILL_FIRE_RL_startDrp ;

  // register drpRdy
  assign drpRdy$D_IN = drp_rdy ;
  assign drpRdy$EN = 1'd1 ;

  // register drpWE
  assign drpWE$D_IN = state != 3'd1 ;
  assign drpWE$EN = state == 3'd1 || WILL_FIRE_RL_startDrp ;

  // register numvecDone
  assign numvecDone$D_IN = numvec_done ;
  assign numvecDone$EN = 1'd1 ;

  // register numvecValid
  assign numvecValid$D_IN = !WILL_FIRE_RL_startDrp ;
  assign numvecValid$EN = WILL_FIRE_RL_startDrp || state == 3'd0 ;

  // register state
  always@(WILL_FIRE_RL_startDrp or state or WILL_FIRE_RL_finishDrpWrite)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_startDrp: state$D_IN = 3'd1;
      state == 3'd1: state$D_IN = 3'd2;
      state == 3'd0: state$D_IN = 3'd3;
      WILL_FIRE_RL_finishDrpWrite: state$D_IN = 3'd4;
      default: state$D_IN = 3'b010 /* unspecified value */ ;
    endcase
  end
  assign state$EN =
	     WILL_FIRE_RL_startDrp || state == 3'd1 || state == 3'd0 ||
	     WILL_FIRE_RL_finishDrpWrite ;

  // handling of inlined registers

  always@(posedge clk)
  begin
    if (resetn == `BSV_RESET_VALUE)
      begin
        drpEn <= `BSV_ASSIGNMENT_DELAY 1'd0;
	drpRdy <= `BSV_ASSIGNMENT_DELAY 1'd0;
	drpWE <= `BSV_ASSIGNMENT_DELAY 1'd0;
	numvecDone <= `BSV_ASSIGNMENT_DELAY 1'd0;
	numvecValid <= `BSV_ASSIGNMENT_DELAY 1'd0;
	state <= `BSV_ASSIGNMENT_DELAY 3'd0;
      end
    else
      begin
        if (drpEn$EN) drpEn <= `BSV_ASSIGNMENT_DELAY drpEn$D_IN;
	if (drpRdy$EN) drpRdy <= `BSV_ASSIGNMENT_DELAY drpRdy$D_IN;
	if (drpWE$EN) drpWE <= `BSV_ASSIGNMENT_DELAY drpWE$D_IN;
	if (numvecDone$EN)
	  numvecDone <= `BSV_ASSIGNMENT_DELAY numvecDone$D_IN;
	if (numvecValid$EN)
	  numvecValid <= `BSV_ASSIGNMENT_DELAY numvecValid$D_IN;
	if (state$EN) state <= `BSV_ASSIGNMENT_DELAY state$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    drpEn = 1'h0;
    drpRdy = 1'h0;
    drpWE = 1'h0;
    numvecDone = 1'h0;
    numvecValid = 1'h0;
    state = 3'h2;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkQDMAConfigurator

