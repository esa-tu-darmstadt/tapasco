//
// Generated by Bluespec Compiler (build 69dee06)
//
// On Thu Jan 13 11:57:02 CET 2022
//
//
// Ports:
// Name                         I/O  size props
// S_AXIS_TX_tready               O     1
// M_AXIS_TX_tvalid               O     1
// M_AXIS_TX_tdata                O   512
// M_AXIS_TX_tlast                O     1
// M_AXIS_TX_tkeep                O    64
// M_AXIS_TX_tDest                O     4
// S_AXIS_RX_tready               O     1
// M_AXIS_RX_tvalid               O     1
// M_AXIS_RX_tdata                O   512
// M_AXIS_RX_tlast                O     1
// M_AXIS_RX_tkeep                O    64
// M_AXIS_RX_tDest                O     4
// ctl_tx_pause_enable            O     9 const
// ctl_tx_pause_req               O     9
// ctl_tx_pause_quanta8           O    16 const
// ctl_tx_pause_refresh_timer8    O    16 const
// ctl_rx_pause_enable            O     9 const
// ctl_rx_pause_ack               O     9
// aclk                           I     1 clock
// aresetn                        I     1 reset
// S_AXIS_TX_tvalid               I     1
// S_AXIS_TX_tdata                I   512 reg
// S_AXIS_TX_tkeep                I    64 reg
// S_AXIS_TX_tDest                I     4 reg
// S_AXIS_TX_tlast                I     1 reg
// M_AXIS_TX_tready               I     1
// S_AXIS_RX_tvalid               I     1
// S_AXIS_RX_tdata                I   512 reg
// S_AXIS_RX_tkeep                I    64 reg
// S_AXIS_RX_tDest                I     4 reg
// S_AXIS_RX_tlast                I     1 reg
// M_AXIS_RX_tready               I     1
// stat_rx_pause_req              I     9 reg
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkEthernetFlowControl(aclk,
			     aresetn,

			     S_AXIS_TX_tready,

			     S_AXIS_TX_tvalid,

			     S_AXIS_TX_tdata,

			     S_AXIS_TX_tkeep,

			     S_AXIS_TX_tDest,

			     S_AXIS_TX_tlast,

			     M_AXIS_TX_tvalid,

			     M_AXIS_TX_tready,

			     M_AXIS_TX_tdata,

			     M_AXIS_TX_tlast,

			     M_AXIS_TX_tkeep,

			     M_AXIS_TX_tDest,

			     S_AXIS_RX_tready,

			     S_AXIS_RX_tvalid,

			     S_AXIS_RX_tdata,

			     S_AXIS_RX_tkeep,

			     S_AXIS_RX_tDest,

			     S_AXIS_RX_tlast,

			     M_AXIS_RX_tvalid,

			     M_AXIS_RX_tready,

			     M_AXIS_RX_tdata,

			     M_AXIS_RX_tlast,

			     M_AXIS_RX_tkeep,

			     M_AXIS_RX_tDest,

			     ctl_tx_pause_enable,

			     ctl_tx_pause_req,

			     ctl_tx_pause_quanta8,

			     ctl_tx_pause_refresh_timer8,

			     ctl_rx_pause_enable,

			     ctl_rx_pause_ack,

			     stat_rx_pause_req);
  input  aclk;
  input  aresetn;

  // value method s_axis_tx_fab_tready
  output S_AXIS_TX_tready;

  // action method s_axis_tx_fab_ptvalid
  input  S_AXIS_TX_tvalid;

  // action method s_axis_tx_fab_ptdata
  input  [511 : 0] S_AXIS_TX_tdata;

  // action method s_axis_tx_fab_ptuser

  // action method s_axis_tx_fab_ptkeep
  input  [63 : 0] S_AXIS_TX_tkeep;

  // action method s_axis_tx_fab_ptDest
  input  [3 : 0] S_AXIS_TX_tDest;

  // action method s_axis_tx_fab_ptlast
  input  S_AXIS_TX_tlast;

  // value method m_axis_tx_fab_tvalid
  output M_AXIS_TX_tvalid;

  // action method m_axis_tx_fab_ptready
  input  M_AXIS_TX_tready;

  // value method m_axis_tx_fab_tdata
  output [511 : 0] M_AXIS_TX_tdata;

  // value method m_axis_tx_fab_tlast
  output M_AXIS_TX_tlast;

  // value method m_axis_tx_fab_tuser

  // value method m_axis_tx_fab_tkeep
  output [63 : 0] M_AXIS_TX_tkeep;

  // value method m_axis_tx_fab_tDest
  output [3 : 0] M_AXIS_TX_tDest;

  // value method s_axis_rx_fab_tready
  output S_AXIS_RX_tready;

  // action method s_axis_rx_fab_ptvalid
  input  S_AXIS_RX_tvalid;

  // action method s_axis_rx_fab_ptdata
  input  [511 : 0] S_AXIS_RX_tdata;

  // action method s_axis_rx_fab_ptuser

  // action method s_axis_rx_fab_ptkeep
  input  [63 : 0] S_AXIS_RX_tkeep;

  // action method s_axis_rx_fab_ptDest
  input  [3 : 0] S_AXIS_RX_tDest;

  // action method s_axis_rx_fab_ptlast
  input  S_AXIS_RX_tlast;

  // value method m_axis_rx_fab_tvalid
  output M_AXIS_RX_tvalid;

  // action method m_axis_rx_fab_ptready
  input  M_AXIS_RX_tready;

  // value method m_axis_rx_fab_tdata
  output [511 : 0] M_AXIS_RX_tdata;

  // value method m_axis_rx_fab_tlast
  output M_AXIS_RX_tlast;

  // value method m_axis_rx_fab_tuser

  // value method m_axis_rx_fab_tkeep
  output [63 : 0] M_AXIS_RX_tkeep;

  // value method m_axis_rx_fab_tDest
  output [3 : 0] M_AXIS_RX_tDest;

  // value method tx_pause_ifc_ctl_tx_pause_enable
  output [8 : 0] ctl_tx_pause_enable;

  // value method tx_pause_ifc_ctl_tx_pause_req
  output [8 : 0] ctl_tx_pause_req;

  // value method tx_pause_ifc_ctl_tx_pause_quanta8
  output [15 : 0] ctl_tx_pause_quanta8;

  // value method tx_pause_ifc_ctl_tx_pause_refresh_timer8
  output [15 : 0] ctl_tx_pause_refresh_timer8;

  // value method rx_pause_ifc_ctl_rx_pause_enable
  output [8 : 0] ctl_rx_pause_enable;

  // value method rx_pause_ifc_ctl_rx_pause_ack
  output [8 : 0] ctl_rx_pause_ack;

  // action method rx_pause_ifc_pause_req
  input  [8 : 0] stat_rx_pause_req;

  // signals for module outputs
  wire [511 : 0] M_AXIS_RX_tdata, M_AXIS_TX_tdata;
  wire [63 : 0] M_AXIS_RX_tkeep, M_AXIS_TX_tkeep;
  wire [15 : 0] ctl_tx_pause_quanta8, ctl_tx_pause_refresh_timer8;
  wire [8 : 0] ctl_rx_pause_ack,
	       ctl_rx_pause_enable,
	       ctl_tx_pause_enable,
	       ctl_tx_pause_req;
  wire [3 : 0] M_AXIS_RX_tDest, M_AXIS_TX_tDest;
  wire M_AXIS_RX_tlast,
       M_AXIS_RX_tvalid,
       M_AXIS_TX_tlast,
       M_AXIS_TX_tvalid,
       S_AXIS_RX_tready,
       S_AXIS_TX_tready;

  // register rxAxiMaster_isRst_isInReset
  reg rxAxiMaster_isRst_isInReset;
  wire rxAxiMaster_isRst_isInReset$D_IN, rxAxiMaster_isRst_isInReset$EN;

  // register rxAxiSlave_isRst_isInReset
  reg rxAxiSlave_isRst_isInReset;
  wire rxAxiSlave_isRst_isInReset$D_IN, rxAxiSlave_isRst_isInReset$EN;

  // register rxCnt
  reg [3 : 0] rxCnt;
  reg [3 : 0] rxCnt$D_IN;
  wire rxCnt$EN;

  // register rxPauseReqAck
  reg rxPauseReqAck;
  wire rxPauseReqAck$D_IN, rxPauseReqAck$EN;

  // register rxState
  reg [1 : 0] rxState;
  reg [1 : 0] rxState$D_IN;
  wire rxState$EN;

  // register txAxiMaster_isRst_isInReset
  reg txAxiMaster_isRst_isInReset;
  wire txAxiMaster_isRst_isInReset$D_IN, txAxiMaster_isRst_isInReset$EN;

  // register txAxiSlave_isRst_isInReset
  reg txAxiSlave_isRst_isInReset;
  wire txAxiSlave_isRst_isInReset$D_IN, txAxiSlave_isRst_isInReset$EN;

  // register txPauseRequest
  reg txPauseRequest;
  wire txPauseRequest$D_IN, txPauseRequest$EN;

  // register txTransferActive
  reg txTransferActive;
  wire txTransferActive$D_IN, txTransferActive$EN;

  // ports of submodule rxAxiMaster_out
  wire [580 : 0] rxAxiMaster_out$D_IN;
  wire rxAxiMaster_out$CLR, rxAxiMaster_out$DEQ, rxAxiMaster_out$ENQ;

  // ports of submodule rxAxiMaster_out_1
  wire [580 : 0] rxAxiMaster_out_1$D_IN, rxAxiMaster_out_1$D_OUT;
  wire rxAxiMaster_out_1$CLR,
       rxAxiMaster_out_1$DEQ,
       rxAxiMaster_out_1$EMPTY_N,
       rxAxiMaster_out_1$ENQ,
       rxAxiMaster_out_1$FULL_N;

  // ports of submodule rxAxiSlave_in
  wire [580 : 0] rxAxiSlave_in$D_IN;
  wire rxAxiSlave_in$CLR, rxAxiSlave_in$DEQ, rxAxiSlave_in$ENQ;

  // ports of submodule rxAxiSlave_in_1
  wire [580 : 0] rxAxiSlave_in_1$D_IN, rxAxiSlave_in_1$D_OUT;
  wire rxAxiSlave_in_1$CLR,
       rxAxiSlave_in_1$DEQ,
       rxAxiSlave_in_1$EMPTY_N,
       rxAxiSlave_in_1$ENQ,
       rxAxiSlave_in_1$FULL_N;

  // ports of submodule rxFifo
  wire [580 : 0] rxFifo$D_IN, rxFifo$D_OUT;
  wire rxFifo$CLR, rxFifo$DEQ, rxFifo$EMPTY_N, rxFifo$ENQ, rxFifo$FULL_N;

  // ports of submodule txAxiMaster_out
  wire [580 : 0] txAxiMaster_out$D_IN;
  wire txAxiMaster_out$CLR, txAxiMaster_out$DEQ, txAxiMaster_out$ENQ;

  // ports of submodule txAxiMaster_out_1
  wire [580 : 0] txAxiMaster_out_1$D_IN, txAxiMaster_out_1$D_OUT;
  wire txAxiMaster_out_1$CLR,
       txAxiMaster_out_1$DEQ,
       txAxiMaster_out_1$EMPTY_N,
       txAxiMaster_out_1$ENQ,
       txAxiMaster_out_1$FULL_N;

  // ports of submodule txAxiSlave_in
  wire [580 : 0] txAxiSlave_in$D_IN;
  wire txAxiSlave_in$CLR, txAxiSlave_in$DEQ, txAxiSlave_in$ENQ;

  // ports of submodule txAxiSlave_in_1
  wire [580 : 0] txAxiSlave_in_1$D_IN, txAxiSlave_in_1$D_OUT;
  wire txAxiSlave_in_1$CLR,
       txAxiSlave_in_1$DEQ,
       txAxiSlave_in_1$EMPTY_N,
       txAxiSlave_in_1$ENQ,
       txAxiSlave_in_1$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_finishTxTransfer,
       WILL_FIRE_RL_initPauseStop,
       WILL_FIRE_RL_requestPause,
       WILL_FIRE_RL_startTxTransfer;

  // inputs to muxes for submodule ports
  wire [3 : 0] MUX_rxCnt$write_1__VAL_1;
  wire [1 : 0] MUX_rxState$write_1__VAL_2;
  wire MUX_rxCnt$write_1__SEL_1,
       MUX_rxCnt$write_1__SEL_2,
       MUX_rxCnt$write_1__SEL_3,
       MUX_rxState$write_1__SEL_1,
       MUX_rxState$write_1__SEL_2,
       MUX_txPauseRequest$write_1__SEL_1,
       MUX_txTransferActive$write_1__SEL_1;

  // value method s_axis_tx_fab_tready
  assign S_AXIS_TX_tready =
	     !txAxiSlave_isRst_isInReset && txAxiSlave_in_1$FULL_N ;

  // value method m_axis_tx_fab_tvalid
  assign M_AXIS_TX_tvalid =
	     !txAxiMaster_isRst_isInReset && txAxiMaster_out_1$EMPTY_N ;

  // value method m_axis_tx_fab_tdata
  assign M_AXIS_TX_tdata =
	     txAxiMaster_out_1$EMPTY_N ?
	       txAxiMaster_out_1$D_OUT[580:69] :
	       512'd0 ;

  // value method m_axis_tx_fab_tlast
  assign M_AXIS_TX_tlast =
	     txAxiMaster_out_1$EMPTY_N && txAxiMaster_out_1$D_OUT[0] ;

  // value method m_axis_tx_fab_tkeep
  assign M_AXIS_TX_tkeep =
	     txAxiMaster_out_1$EMPTY_N ?
	       txAxiMaster_out_1$D_OUT[68:5] :
	       64'd0 ;

  // value method m_axis_tx_fab_tDest
  assign M_AXIS_TX_tDest =
	     txAxiMaster_out_1$EMPTY_N ? txAxiMaster_out_1$D_OUT[4:1] : 4'd0 ;

  // value method s_axis_rx_fab_tready
  assign S_AXIS_RX_tready =
	     !rxAxiSlave_isRst_isInReset && rxAxiSlave_in_1$FULL_N ;

  // value method m_axis_rx_fab_tvalid
  assign M_AXIS_RX_tvalid =
	     !rxAxiMaster_isRst_isInReset && rxAxiMaster_out_1$EMPTY_N ;

  // value method m_axis_rx_fab_tdata
  assign M_AXIS_RX_tdata =
	     rxAxiMaster_out_1$EMPTY_N ?
	       rxAxiMaster_out_1$D_OUT[580:69] :
	       512'd0 ;

  // value method m_axis_rx_fab_tlast
  assign M_AXIS_RX_tlast =
	     rxAxiMaster_out_1$EMPTY_N && rxAxiMaster_out_1$D_OUT[0] ;

  // value method m_axis_rx_fab_tkeep
  assign M_AXIS_RX_tkeep =
	     rxAxiMaster_out_1$EMPTY_N ?
	       rxAxiMaster_out_1$D_OUT[68:5] :
	       64'd0 ;

  // value method m_axis_rx_fab_tDest
  assign M_AXIS_RX_tDest =
	     rxAxiMaster_out_1$EMPTY_N ? rxAxiMaster_out_1$D_OUT[4:1] : 4'd0 ;

  // value method tx_pause_ifc_ctl_tx_pause_enable
  assign ctl_tx_pause_enable = 9'h100 ;

  // value method tx_pause_ifc_ctl_tx_pause_req
  assign ctl_tx_pause_req = { txPauseRequest, 8'h0 } ;

  // value method tx_pause_ifc_ctl_tx_pause_quanta8
  assign ctl_tx_pause_quanta8 = 16'd128 ;

  // value method tx_pause_ifc_ctl_tx_pause_refresh_timer8
  assign ctl_tx_pause_refresh_timer8 = 16'd96 ;

  // value method rx_pause_ifc_ctl_rx_pause_enable
  assign ctl_rx_pause_enable = 9'h100 ;

  // value method rx_pause_ifc_ctl_rx_pause_ack
  assign ctl_rx_pause_ack = { rxPauseReqAck, 8'h0 } ;

  // submodule rxAxiMaster_out
  FIFO2 #(.width(32'd581), .guarded(1'd1)) rxAxiMaster_out(.RST(aresetn),
							   .CLK(aclk),
							   .D_IN(rxAxiMaster_out$D_IN),
							   .ENQ(rxAxiMaster_out$ENQ),
							   .DEQ(rxAxiMaster_out$DEQ),
							   .CLR(rxAxiMaster_out$CLR),
							   .D_OUT(),
							   .FULL_N(),
							   .EMPTY_N());

  // submodule rxAxiMaster_out_1
  FIFO2 #(.width(32'd581), .guarded(1'd1)) rxAxiMaster_out_1(.RST(aresetn),
							     .CLK(aclk),
							     .D_IN(rxAxiMaster_out_1$D_IN),
							     .ENQ(rxAxiMaster_out_1$ENQ),
							     .DEQ(rxAxiMaster_out_1$DEQ),
							     .CLR(rxAxiMaster_out_1$CLR),
							     .D_OUT(rxAxiMaster_out_1$D_OUT),
							     .FULL_N(rxAxiMaster_out_1$FULL_N),
							     .EMPTY_N(rxAxiMaster_out_1$EMPTY_N));

  // submodule rxAxiSlave_in
  FIFO2 #(.width(32'd581), .guarded(1'd1)) rxAxiSlave_in(.RST(aresetn),
							 .CLK(aclk),
							 .D_IN(rxAxiSlave_in$D_IN),
							 .ENQ(rxAxiSlave_in$ENQ),
							 .DEQ(rxAxiSlave_in$DEQ),
							 .CLR(rxAxiSlave_in$CLR),
							 .D_OUT(),
							 .FULL_N(),
							 .EMPTY_N());

  // submodule rxAxiSlave_in_1
  FIFO2 #(.width(32'd581), .guarded(1'd1)) rxAxiSlave_in_1(.RST(aresetn),
							   .CLK(aclk),
							   .D_IN(rxAxiSlave_in_1$D_IN),
							   .ENQ(rxAxiSlave_in_1$ENQ),
							   .DEQ(rxAxiSlave_in_1$DEQ),
							   .CLR(rxAxiSlave_in_1$CLR),
							   .D_OUT(rxAxiSlave_in_1$D_OUT),
							   .FULL_N(rxAxiSlave_in_1$FULL_N),
							   .EMPTY_N(rxAxiSlave_in_1$EMPTY_N));

  // submodule rxFifo
  FIFO2 #(.width(32'd581), .guarded(1'd1)) rxFifo(.RST(aresetn),
						  .CLK(aclk),
						  .D_IN(rxFifo$D_IN),
						  .ENQ(rxFifo$ENQ),
						  .DEQ(rxFifo$DEQ),
						  .CLR(rxFifo$CLR),
						  .D_OUT(rxFifo$D_OUT),
						  .FULL_N(rxFifo$FULL_N),
						  .EMPTY_N(rxFifo$EMPTY_N));

  // submodule txAxiMaster_out
  FIFO2 #(.width(32'd581), .guarded(1'd1)) txAxiMaster_out(.RST(aresetn),
							   .CLK(aclk),
							   .D_IN(txAxiMaster_out$D_IN),
							   .ENQ(txAxiMaster_out$ENQ),
							   .DEQ(txAxiMaster_out$DEQ),
							   .CLR(txAxiMaster_out$CLR),
							   .D_OUT(),
							   .FULL_N(),
							   .EMPTY_N());

  // submodule txAxiMaster_out_1
  FIFO2 #(.width(32'd581), .guarded(1'd1)) txAxiMaster_out_1(.RST(aresetn),
							     .CLK(aclk),
							     .D_IN(txAxiMaster_out_1$D_IN),
							     .ENQ(txAxiMaster_out_1$ENQ),
							     .DEQ(txAxiMaster_out_1$DEQ),
							     .CLR(txAxiMaster_out_1$CLR),
							     .D_OUT(txAxiMaster_out_1$D_OUT),
							     .FULL_N(txAxiMaster_out_1$FULL_N),
							     .EMPTY_N(txAxiMaster_out_1$EMPTY_N));

  // submodule txAxiSlave_in
  FIFO2 #(.width(32'd581), .guarded(1'd1)) txAxiSlave_in(.RST(aresetn),
							 .CLK(aclk),
							 .D_IN(txAxiSlave_in$D_IN),
							 .ENQ(txAxiSlave_in$ENQ),
							 .DEQ(txAxiSlave_in$DEQ),
							 .CLR(txAxiSlave_in$CLR),
							 .D_OUT(),
							 .FULL_N(),
							 .EMPTY_N());

  // submodule txAxiSlave_in_1
  FIFO2 #(.width(32'd581), .guarded(1'd1)) txAxiSlave_in_1(.RST(aresetn),
							   .CLK(aclk),
							   .D_IN(txAxiSlave_in_1$D_IN),
							   .ENQ(txAxiSlave_in_1$ENQ),
							   .DEQ(txAxiSlave_in_1$DEQ),
							   .CLR(txAxiSlave_in_1$CLR),
							   .D_OUT(txAxiSlave_in_1$D_OUT),
							   .FULL_N(txAxiSlave_in_1$FULL_N),
							   .EMPTY_N(txAxiSlave_in_1$EMPTY_N));

  // rule RL_requestPause
  assign WILL_FIRE_RL_requestPause = rxState == 2'd0 && !rxFifo$FULL_N ;

  // rule RL_initPauseStop
  assign WILL_FIRE_RL_initPauseStop = rxState == 2'd2 && !rxFifo$EMPTY_N ;

  // rule RL_startTxTransfer
  assign WILL_FIRE_RL_startTxTransfer =
	     txAxiSlave_in_1$EMPTY_N && txAxiMaster_out_1$FULL_N &&
	     !rxPauseReqAck &&
	     !txTransferActive ;

  // rule RL_finishTxTransfer
  assign WILL_FIRE_RL_finishTxTransfer =
	     txAxiSlave_in_1$EMPTY_N && txAxiMaster_out_1$FULL_N &&
	     txTransferActive ;

  // inputs to muxes for submodule ports
  assign MUX_rxCnt$write_1__SEL_1 = rxState == 2'd1 && rxCnt != 4'hF ;
  assign MUX_rxCnt$write_1__SEL_2 =
	     rxState == 2'd3 && !rxFifo$EMPTY_N && rxCnt != 4'hF ;
  assign MUX_rxCnt$write_1__SEL_3 =
	     WILL_FIRE_RL_initPauseStop || WILL_FIRE_RL_requestPause ;
  assign MUX_rxState$write_1__SEL_1 = rxState == 2'd1 && rxCnt == 4'hF ;
  assign MUX_rxState$write_1__SEL_2 =
	     rxState == 2'd3 && (rxFifo$EMPTY_N || rxCnt == 4'hF) ;
  assign MUX_txPauseRequest$write_1__SEL_1 =
	     rxState == 2'd3 && !rxFifo$EMPTY_N && rxCnt == 4'hF ;
  assign MUX_txTransferActive$write_1__SEL_1 =
	     WILL_FIRE_RL_finishTxTransfer && txAxiSlave_in_1$D_OUT[0] ;
  assign MUX_rxCnt$write_1__VAL_1 = rxCnt + 4'd1 ;
  assign MUX_rxState$write_1__VAL_2 = rxFifo$EMPTY_N ? 2'd2 : 2'd0 ;

  // register rxAxiMaster_isRst_isInReset
  assign rxAxiMaster_isRst_isInReset$D_IN = 1'd0 ;
  assign rxAxiMaster_isRst_isInReset$EN = rxAxiMaster_isRst_isInReset ;

  // register rxAxiSlave_isRst_isInReset
  assign rxAxiSlave_isRst_isInReset$D_IN = 1'd0 ;
  assign rxAxiSlave_isRst_isInReset$EN = rxAxiSlave_isRst_isInReset ;

  // register rxCnt
  always@(MUX_rxCnt$write_1__SEL_1 or
	  MUX_rxCnt$write_1__VAL_1 or
	  MUX_rxCnt$write_1__SEL_2 or MUX_rxCnt$write_1__SEL_3)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_rxCnt$write_1__SEL_1: rxCnt$D_IN = MUX_rxCnt$write_1__VAL_1;
      MUX_rxCnt$write_1__SEL_2: rxCnt$D_IN = MUX_rxCnt$write_1__VAL_1;
      MUX_rxCnt$write_1__SEL_3: rxCnt$D_IN = 4'd0;
      default: rxCnt$D_IN = 4'b1010 /* unspecified value */ ;
    endcase
  end
  assign rxCnt$EN =
	     rxState == 2'd1 && rxCnt != 4'hF ||
	     rxState == 2'd3 && !rxFifo$EMPTY_N && rxCnt != 4'hF ||
	     WILL_FIRE_RL_initPauseStop ||
	     WILL_FIRE_RL_requestPause ;

  // register rxPauseReqAck
  assign rxPauseReqAck$D_IN = stat_rx_pause_req[8] ;
  assign rxPauseReqAck$EN = 1'd1 ;

  // register rxState
  always@(MUX_rxState$write_1__SEL_1 or
	  MUX_rxState$write_1__SEL_2 or
	  MUX_rxState$write_1__VAL_2 or
	  WILL_FIRE_RL_requestPause or WILL_FIRE_RL_initPauseStop)
  begin
    case (1'b1) // synopsys parallel_case
      MUX_rxState$write_1__SEL_1: rxState$D_IN = 2'd2;
      MUX_rxState$write_1__SEL_2: rxState$D_IN = MUX_rxState$write_1__VAL_2;
      WILL_FIRE_RL_requestPause: rxState$D_IN = 2'd1;
      WILL_FIRE_RL_initPauseStop: rxState$D_IN = 2'd3;
      default: rxState$D_IN = 2'b10 /* unspecified value */ ;
    endcase
  end
  assign rxState$EN =
	     rxState == 2'd1 && rxCnt == 4'hF ||
	     rxState == 2'd3 && (rxFifo$EMPTY_N || rxCnt == 4'hF) ||
	     WILL_FIRE_RL_requestPause ||
	     WILL_FIRE_RL_initPauseStop ;

  // register txAxiMaster_isRst_isInReset
  assign txAxiMaster_isRst_isInReset$D_IN = 1'd0 ;
  assign txAxiMaster_isRst_isInReset$EN = txAxiMaster_isRst_isInReset ;

  // register txAxiSlave_isRst_isInReset
  assign txAxiSlave_isRst_isInReset$D_IN = 1'd0 ;
  assign txAxiSlave_isRst_isInReset$EN = txAxiSlave_isRst_isInReset ;

  // register txPauseRequest
  assign txPauseRequest$D_IN = !MUX_txPauseRequest$write_1__SEL_1 ;
  assign txPauseRequest$EN =
	     rxState == 2'd3 && !rxFifo$EMPTY_N && rxCnt == 4'hF ||
	     WILL_FIRE_RL_requestPause ;

  // register txTransferActive
  assign txTransferActive$D_IN = !MUX_txTransferActive$write_1__SEL_1 ;
  assign txTransferActive$EN =
	     WILL_FIRE_RL_finishTxTransfer && txAxiSlave_in_1$D_OUT[0] ||
	     WILL_FIRE_RL_startTxTransfer ;

  // submodule rxAxiMaster_out
  assign rxAxiMaster_out$D_IN = 581'h0 ;
  assign rxAxiMaster_out$ENQ = 1'b0 ;
  assign rxAxiMaster_out$DEQ = 1'b0 ;
  assign rxAxiMaster_out$CLR = 1'b0 ;

  // submodule rxAxiMaster_out_1
  assign rxAxiMaster_out_1$D_IN = rxFifo$D_OUT ;
  assign rxAxiMaster_out_1$ENQ = rxFifo$EMPTY_N && rxAxiMaster_out_1$FULL_N ;
  assign rxAxiMaster_out_1$DEQ =
	     rxAxiMaster_out_1$EMPTY_N && !rxAxiMaster_isRst_isInReset &&
	     M_AXIS_RX_tready ;
  assign rxAxiMaster_out_1$CLR = 1'b0 ;

  // submodule rxAxiSlave_in
  assign rxAxiSlave_in$D_IN = 581'h0 ;
  assign rxAxiSlave_in$ENQ = 1'b0 ;
  assign rxAxiSlave_in$DEQ = 1'b0 ;
  assign rxAxiSlave_in$CLR = 1'b0 ;

  // submodule rxAxiSlave_in_1
  assign rxAxiSlave_in_1$D_IN =
	     { S_AXIS_RX_tdata,
	       S_AXIS_RX_tkeep,
	       S_AXIS_RX_tDest,
	       S_AXIS_RX_tlast } ;
  assign rxAxiSlave_in_1$ENQ =
	     rxAxiSlave_in_1$FULL_N && !rxAxiSlave_isRst_isInReset &&
	     S_AXIS_RX_tvalid ;
  assign rxAxiSlave_in_1$DEQ = rxAxiSlave_in_1$EMPTY_N && rxFifo$FULL_N ;
  assign rxAxiSlave_in_1$CLR = 1'b0 ;

  // submodule rxFifo
  assign rxFifo$D_IN = rxAxiSlave_in_1$D_OUT ;
  assign rxFifo$ENQ = rxAxiSlave_in_1$EMPTY_N && rxFifo$FULL_N ;
  assign rxFifo$DEQ = rxFifo$EMPTY_N && rxAxiMaster_out_1$FULL_N ;
  assign rxFifo$CLR = 1'b0 ;

  // submodule txAxiMaster_out
  assign txAxiMaster_out$D_IN = 581'h0 ;
  assign txAxiMaster_out$ENQ = 1'b0 ;
  assign txAxiMaster_out$DEQ = 1'b0 ;
  assign txAxiMaster_out$CLR = 1'b0 ;

  // submodule txAxiMaster_out_1
  assign txAxiMaster_out_1$D_IN = txAxiSlave_in_1$D_OUT ;
  assign txAxiMaster_out_1$ENQ =
	     WILL_FIRE_RL_finishTxTransfer || WILL_FIRE_RL_startTxTransfer ;
  assign txAxiMaster_out_1$DEQ =
	     txAxiMaster_out_1$EMPTY_N && !txAxiMaster_isRst_isInReset &&
	     M_AXIS_TX_tready ;
  assign txAxiMaster_out_1$CLR = 1'b0 ;

  // submodule txAxiSlave_in
  assign txAxiSlave_in$D_IN = 581'h0 ;
  assign txAxiSlave_in$ENQ = 1'b0 ;
  assign txAxiSlave_in$DEQ = 1'b0 ;
  assign txAxiSlave_in$CLR = 1'b0 ;

  // submodule txAxiSlave_in_1
  assign txAxiSlave_in_1$D_IN =
	     { S_AXIS_TX_tdata,
	       S_AXIS_TX_tkeep,
	       S_AXIS_TX_tDest,
	       S_AXIS_TX_tlast } ;
  assign txAxiSlave_in_1$ENQ =
	     txAxiSlave_in_1$FULL_N && !txAxiSlave_isRst_isInReset &&
	     S_AXIS_TX_tvalid ;
  assign txAxiSlave_in_1$DEQ =
	     WILL_FIRE_RL_finishTxTransfer || WILL_FIRE_RL_startTxTransfer ;
  assign txAxiSlave_in_1$CLR = 1'b0 ;

  // handling of inlined registers

  always@(posedge aclk)
  begin
    if (aresetn == `BSV_RESET_VALUE)
      begin
        rxCnt <= `BSV_ASSIGNMENT_DELAY 4'd0;
	rxPauseReqAck <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rxState <= `BSV_ASSIGNMENT_DELAY 2'd0;
	txPauseRequest <= `BSV_ASSIGNMENT_DELAY 1'd0;
	txTransferActive <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (rxCnt$EN) rxCnt <= `BSV_ASSIGNMENT_DELAY rxCnt$D_IN;
	if (rxPauseReqAck$EN)
	  rxPauseReqAck <= `BSV_ASSIGNMENT_DELAY rxPauseReqAck$D_IN;
	if (rxState$EN) rxState <= `BSV_ASSIGNMENT_DELAY rxState$D_IN;
	if (txPauseRequest$EN)
	  txPauseRequest <= `BSV_ASSIGNMENT_DELAY txPauseRequest$D_IN;
	if (txTransferActive$EN)
	  txTransferActive <= `BSV_ASSIGNMENT_DELAY txTransferActive$D_IN;
      end
  end

  always@(posedge aclk or `BSV_RESET_EDGE aresetn)
  if (aresetn == `BSV_RESET_VALUE)
    begin
      rxAxiMaster_isRst_isInReset <= `BSV_ASSIGNMENT_DELAY 1'd1;
      rxAxiSlave_isRst_isInReset <= `BSV_ASSIGNMENT_DELAY 1'd1;
      txAxiMaster_isRst_isInReset <= `BSV_ASSIGNMENT_DELAY 1'd1;
      txAxiSlave_isRst_isInReset <= `BSV_ASSIGNMENT_DELAY 1'd1;
    end
  else
    begin
      if (rxAxiMaster_isRst_isInReset$EN)
	rxAxiMaster_isRst_isInReset <= `BSV_ASSIGNMENT_DELAY
	    rxAxiMaster_isRst_isInReset$D_IN;
      if (rxAxiSlave_isRst_isInReset$EN)
	rxAxiSlave_isRst_isInReset <= `BSV_ASSIGNMENT_DELAY
	    rxAxiSlave_isRst_isInReset$D_IN;
      if (txAxiMaster_isRst_isInReset$EN)
	txAxiMaster_isRst_isInReset <= `BSV_ASSIGNMENT_DELAY
	    txAxiMaster_isRst_isInReset$D_IN;
      if (txAxiSlave_isRst_isInReset$EN)
	txAxiSlave_isRst_isInReset <= `BSV_ASSIGNMENT_DELAY
	    txAxiSlave_isRst_isInReset$D_IN;
    end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rxAxiMaster_isRst_isInReset = 1'h0;
    rxAxiSlave_isRst_isInReset = 1'h0;
    rxCnt = 4'hA;
    rxPauseReqAck = 1'h0;
    rxState = 2'h2;
    txAxiMaster_isRst_isInReset = 1'h0;
    txAxiSlave_isRst_isInReset = 1'h0;
    txPauseRequest = 1'h0;
    txTransferActive = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkEthernetFlowControl

